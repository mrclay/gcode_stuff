<?php

namespace MrClay\Crypt;

use MrClay\Crypt\Cipher\Base;
use MrClay\Crypt\KeyDeriver;
use MrClay\Crypt\ByteString;

/**
 * Simplified encryption/decryption model, using uniquely derived keys for each encryption and structured
 * cipherText storage container for flexible encoding (e.g. in Base64).
 *
 * The default cipher is AES-256 (aka Rijndael-256) in counter mode.
 * @link http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html
 */
class Encryption {

    /**
     * @var Base
     */
    protected $cipher;

    /**
     * @var string
     */
    protected $baseKey;

    /**
     * @var KeyDeriver
     */
    protected $keyDeriver;

    /**
     * @param string $baseKey static key from which unique encryption keys will be derived. The longer the better!
     * @param Cipher\Base|null $cipher
     * @param KeyDeriver|null $keyDeriver for creating unique keys from the baseKey
     */
    public function __construct($baseKey, Base $cipher = null, KeyDeriver $keyDeriver = null)
    {
        $this->baseKey = $baseKey;
        if (! $cipher) {
            $cipher = new Cipher\Rijndael256();
        }
        if (! $keyDeriver) {
            $keyDeriver = new KeyDeriver();
        }
        $keyDeriver->keyLength = $cipher->getKeySize();
        $this->cipher = $cipher;
        $this->keyDeriver = $keyDeriver;
    }

    /**
     * Encrypt plainText with a uniquely derived key
     *
     * @param $plainText
     * @return Container values required to decrypt [cipherText, IV, salt, HMAC(cipherText+IV+salt)]
     */
    public function encrypt($plainText)
    {
        // create a new salt and use that to derived a new key, too
        list($derivedKey, $salt) = $this->keyDeriver->pbkdf2($this->baseKey);
        $this->cipher->setKey($derivedKey);
        $cipherText = $this->cipher->encrypt($plainText);
        $iv = $this->cipher->getIv(); // was created just before encryption, must store

        // we choose encrypt-then-HMAC for several reasons
        // @link http://www.daemonology.net/blog/2009-06-24-encrypt-then-mac.html
        // Note that deriving a separate key for HMAC would be unnecessary; we already have a
        // key created with PBKDF2
        $hmacInput = $cipherText->getBytes() . $iv->getBytes() . $salt->getBytes();
        $macBytes = hash_hmac('sha256', $hmacInput, $derivedKey->getBytes(), true);

        return new Container(array(
            $cipherText,
            $iv,
            $salt,
            new ByteString($macBytes),
        ));
    }

    /**
     * Decrypt a storage container to plainText
     *
     * @param Container $cont values generated by encrypt() [cipherText, IV, salt, HMAC(cipherText+IV+salt)]
     * @return string|false false on failure
     */
    public function decrypt(Container $cont)
    {
        if (count($cont) !== 4) {
            return false;
        }
        list($cipherText, $iv, $salt, $storedMac) = $cont;
        list($derivedKey, $salt) = $this->keyDeriver->pbkdf2($this->baseKey, $salt);
        $hmacInput = $cipherText->getBytes() . $iv->getBytes() . $salt->getBytes();
        $macBytes = hash_hmac('sha256', $hmacInput, $derivedKey->getBytes(), true);
        if ($macBytes !== $storedMac->getBytes()) {
            return false; // something was tampered with, don't even need to decrypt
        }
        $this->cipher->setKey($derivedKey);
        $this->cipher->setIv($iv);
        return $this->cipher->decrypt($cipherText);
    }
}
